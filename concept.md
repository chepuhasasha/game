## Суть Игры

Игроку предстоит восстановить исходный 3D-куб из отдельных параллелепипедов (коробок). Изначально куб, разбитый на воксели (например, 10x10x10 вокселей), алгоритмически разрезается на заданное количество коробок, которые затем попадают в очередь загрузки.

## Интерфейс

  - **Контейнер**: Центральная область на экране, которую необходимо заполнить (рамка исходного куба).
  - **Очередь**: Панель справа. В ней по вертикали расположены коробки, выданные в случайном порядке.
  - **Буфер**: Временное хранилище, куда игрок может складывать коробки самостоятельно.
## Управление и Игровой Процесс

1.  **Выбор коробки:** Игрок берёт коробку из Очереди или Буфера. Это начинает новый цикл размещения.
2.  **Размещение:** Выбранная коробка располагается над Контейнером.
      - Игрок может двигать её в пределах плоскости **(влево/вправо/вперед/назад)** с шагом в 1 воксель спомошью свайпа в нужном направлении.
      - На дно контейнера проецируется тень текущего положения коробки.
      - Коробку можно врашать на 90 градусов вокруг любой оси
3.  **Загрузка**: Кнопка "Загрузить" опускает коробку вертикально вниз до первого препятствия (аналогично механике Тетриса).
4.  **Управление Буфером**:
      - Игрок может отправить коробку из Контейнера в Буфер, но только если на ней не лежит другая коробка. Это требует от игрока "раскапывать" неправильно расположенные элементы, чтобы добраться до нужной коробки.


## Негативные эффекты для коробок

| Название        | Ограничения                         | Визуальный стиль                                                                                                                                                                                | Key          |
| --------------- | ----------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------ |
| **Хрупкая**     | На нее нельзя ствить другие коробки | Стеклянгый блок с трешенами                                                                                                                                                                     | FRAGILE      |
| **Некантуемая** | Нельзя врашать                      | аквариум с водой, закрытый металической сеткой сверху (чтобы можно было ставить коробки меньшего размера на нее), вода бултыхается при перемешении коробки, быстрее перемешение - больше капель | NON-TILTABLE |

*эффекты могут комбенироватся

## Бустеры

**Удалить коробку** - на случай, если не удастся впихнуть коробку в контейнер.

**Отсортировать коробки** - в очереди коробки идут по порядку, то есть в начале очереди те коробки, которые изначально были снизу, это удобно для постепенного заполнения контейнера.

**Показывать исходную позицию** - при размешении коробки (когда она еще на верхней плоскости контейнера) в контейнере подсвечивается область в которой коробка стояла изначально до разбиения контейнера.

## Система подсчета очков
Продумать

## Генерация уровня
### Шаг 1
Создаем 3х мерную матрицу из вокселей (куб 1×1×1) утсановленной размерности `size` (зависит от сложности уровня). Например если `size = 10` то мы получаем куб состояший из `10×10×10` вокселей. Каждый воксель имеет целочисленные координаты, пример объекта:
```typescript
interface Point {
  x: number
  y: number
  z: number
}

interface Voxel extends Point {
  id: number
}
```
### Шаг 2
Гинерируется рандомный 8ми значный цифровой `seed = 93829105` . 
Суть разбить куб из вокселей на коробки.
На основании `seed` объеденяем отдельные воксели в коробки (группа вокселей объединенная в параллелепипед). Вычесляем центр координат у групы и устанавливаем как `position` у коробки, `width, height, depth` устанавливабтся как целочисленые значения. Пример объекта коробки:
```typescript
interface Box {
  id: number
  readonly position: Point // позиция при разбиении
  location: 
    | 'CONTAINER' 
    | 'QUEUE' 
    | 'BUFFER'
  width: number
  height: number
  depth: number
  debuffs: string[]
  playerPosition?: Point // для взаимодействий игрока в области CONTAINER
}
```

Алгоритм разбиения на коробки должен примемать количество конечных коробок `count`. Важна **повторяемость результата**, если перемменные не меняются то обьеденение в коробки всегда происходит с **повторяемым результатом.** После разбиения коробки отправляются в *очередь*.
